syntax = "proto2";
package hw.trezor.messages.liquid;

// Sugar for easier handling in Java
option java_package = "com.satoshilabs.trezor.lib.protobuf";
option java_outer_classname = "TrezorMessageLiquid";

message LiquidAmount {
    optional uint64 value = 1;
    optional bytes value_blind = 2;         // 32-bytes or None (-> should be derived on-device)
    optional bytes asset = 3;               // 32-bytes
    optional bytes asset_blind = 4;         // 32-bytes or None (-> should be derived on-device)
}

/**
 * Request: Blind specified output
 * @start
 * @next LiquidBlindedOutput
 */
message LiquidBlindOutput {
    optional LiquidAmount amount = 1;
    optional bytes ecdh_pubkey = 2;         // recipient ECDH pubkey, for ECDH nonce generation
    optional bytes ecdh_privkey = 3;        // our ECDH private key, 32-bytes or None (-> should be derived on-device)
    optional bytes script_pubkey = 4;

    // Used for surjection proof generation:
    optional bytes random_seed32 = 5;       // for input asset index selection
}

/**
 * Response: blinded output
 * @end
 */
message LiquidBlindedOutput {
    optional bytes conf_value = 1;
    optional bytes conf_asset = 2;
    optional bytes ecdh_pubkey = 3;
    optional bytes script_pubkey = 4;       // same from LiquidBlindOutput
    optional bytes range_proof = 5;
    optional bytes surjection_proof = 6;
}


message LiquidUnblindOutput {
    optional LiquidBlindedOutput blinded = 1;
    optional bytes ecdh_privkey = 2;        // -> should be derived on-device
}

message LiquidBalanceBlinds {
    repeated LiquidAmount inputs = 1;  // only `value`, `value_blind` and `asset_blind` are used
    repeated LiquidAmount outputs = 2;  // only `value`, `value_blind` and `asset_blind` are used
}

message LiquidBlindTx {
    repeated LiquidAmount inputs = 1;
    repeated LiquidBlindOutput outputs = 2;
}

message LiquidBlindTxRequest {
    optional uint32 output_index = 1;
}
