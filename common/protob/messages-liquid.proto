syntax = "proto2";
package hw.trezor.messages.liquid;

// Sugar for easier handling in Java
option java_package = "com.satoshilabs.trezor.lib.protobuf";
option java_outer_classname = "TrezorMessageLiquid";

message LiquidAmount {
    optional uint64 value = 1;
    optional bytes value_blind = 2;         // 32-bytes or None (-> should be derived on-device)
    optional bytes asset = 3;               // 32-bytes
    optional bytes asset_blind = 4;         // 32-bytes or None (-> should be derived on-device)
}

/**
 * Request: Blind specified output
 * @start
 * @next LiquidBlindedOutput
 */
message LiquidBlindOutput {
    optional LiquidAmount amount = 1;
    optional bytes ecdh_pubkey = 2;         // recipient ECDH pubkey, for ECDH nonce generation
    optional bytes ecdh_privkey = 3;        // our ECDH private key, 32-bytes or None (-> should be derived on-device)
    optional bytes script_pubkey = 4;

    // Used for surjection proof generation:
    optional bytes random_seed32 = 5;       // for input asset index selection
}

/**
 * Response: blinded output
 * @end
 */
message LiquidBlindedOutput {
    optional bytes conf_value = 1;
    optional bytes conf_asset = 2;
    optional bytes ecdh_pubkey = 3;
    optional bytes script_pubkey = 4;       // same from LiquidBlindOutput
    optional bytes range_proof = 5;
    optional bytes surjection_proof = 6;
}


message LiquidUnblindOutput {
    optional LiquidBlindedOutput blinded = 1;
    optional bytes ecdh_privkey = 2;        // -> should be derived on-device
}

message LiquidBalanceBlinds {
    repeated LiquidAmount inputs = 1;  // only `value`, `value_blind` and `asset_blind` are used
    repeated LiquidAmount outputs = 2;  // only `value`, `value_blind` and `asset_blind` are used
}

message LiquidBlindTx {
    repeated LiquidAmount inputs = 1;
    repeated LiquidBlindOutput outputs = 2;
}

message LiquidBlindTxRequest {
    optional uint32 output_index = 1;
}

// One-shot signature request (WIP: NOT SAFE!!!)
message LiquidSignTx {
    optional uint32 version = 1;
    repeated LiquidSignTxInput inputs = 2;
    repeated LiquidSignTxOutput outputs = 3;
    optional uint32 lock_time = 4;
    optional uint32 hash_type = 5;

    message LiquidSignTxInput {
        optional bytes prev_hash = 1;
        optional uint32 prev_index = 2;
        optional uint32 sequence = 3;
        optional bytes issuance = 4;
        optional bytes value = 5;  // for segwit

        optional bytes script_code = 6;  // -> should be derived on-device
        optional bytes sign_privkey = 7;  // -> should be derived on-device
    }

    message LiquidSignTxOutput {
        optional bytes asset = 1;
        optional bytes value = 2;
        optional bytes nonce = 3;  // ECDH pubkey
        optional bytes script_pubkey = 4;
    }
}

message LiquidSignedTx {
    repeated LiquidSignature sigs = 1;  // for each input

    message LiquidSignature {
        optional bytes digest = 1;
        optional bytes pubkey = 2;
        optional bytes sigder = 3;
    }
}
